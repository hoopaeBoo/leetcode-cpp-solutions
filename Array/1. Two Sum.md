### **Intuition**
The problem requires us to find two indices in an array where the sum of their corresponding values equals a given target. The naive approach would involve checking every pair of numbers (brute force), but this is inefficient. Instead, we can use a hash table (unordered_map) to store visited elements, allowing us to find the complement efficiently.

---

### **Approach**
1. **Use a hash map (`unordered_map<int, int>`)**:
   - This will store the value of each number as the key and its index as the value.
   
2. **Iterate through the array**:
   - For each element `nums[i]`, compute its **complement** (`target - nums[i]`).
   - Check if this complement exists in the map.
   - If found, return the indices `{map[complement], i}`.
   - Otherwise, store `nums[i]` with its index in the map and continue.

3. **Early exit**:
   - As soon as we find the required pair, we return the result immediately, making the approach very efficient.

---

### **Complexity Analysis**
- **Time Complexity**:  
  - Each lookup and insertion in an `unordered_map` is **O(1)** on average.
  - We traverse the array once (`O(n)`) and perform constant-time operations for each element.
  - Thus, the overall complexity is **O(n)**.

- **Space Complexity**:  
  - In the worst case, we store all `n` elements in the hash map.
  - Hence, the space complexity is **O(n)**.

---

### **Code**
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> m;
        for (int i = 0; i < nums.size(); ++i) {
            int complement = target - nums[i];
            if (m.count(complement)) return {m[complement], i};
            m[nums[i]] = i;
        }
        return {};
    }
};
```
