### **LeetCode C++ Solution: Longest Substring Without Repeating Characters**  

## **1Ô∏è‚É£ Problem Understanding**  
### **üìå Intuition**  
The problem requires us to find the length of the longest contiguous substring that contains no repeating characters. Given a string, we need to efficiently determine this maximum length.

Key observations:
- A brute-force approach would check every possible substring, which is inefficient.
- Instead, a **Sliding Window** approach allows us to dynamically track the substring while ensuring characters are unique.
- We use a **hash set** (or map) to store characters currently in the window.

### **üöÄ Approach**  
To solve the problem efficiently, we use the **Sliding Window with Hash Map** method:

1. **Initialize Two Pointers**:  
   - `left`: Denotes the start of the current substring.
   - `right`: Expands the window by adding new characters.
   
2. **Use a Hash Map**:  
   - Store the most recent index of each character.
   - This helps quickly identify and remove duplicates.

3. **Expand the Window**:  
   - Move `right` pointer and check if the character exists in the hash map.
   - If it does, move `left` to ensure all characters remain unique.

4. **Update Maximum Length**:  
   - Keep track of the longest valid substring encountered.

### **‚è±Ô∏è Complexity Analysis**  
- **Time Complexity**: **O(n)** ‚Üí Each character is processed at most twice (once when adding, once when moving `left`).  
- **Space Complexity**: **O(1)** ‚Üí Since the character set is limited (ASCII 128 or Unicode), the hash table has a fixed upper bound.

---

## **2Ô∏è‚É£ LeetCode Submission**  
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> charIndex;
        int maxLength = 0, left = 0;

        for (int right = 0; right < s.length(); right++) {
            if (charIndex.find(s[right]) != charIndex.end() && charIndex[s[right]] >= left) {
                left = charIndex[s[right]] + 1;
            }
            charIndex[s[right]] = right;
            maxLength = max(maxLength, right - left + 1);
        }
        return maxLength;
    }
};
```

---

## **3Ô∏è‚É£ Running Locally**  
### **‚úÖ Steps**  
1. **Create a file**: `longest_substring.cpp`  
2. **Wrap the `Solution` class** inside `main()`  
3. **Include necessary headers**  
4. **Handle input/output for local execution**  
5. **Compile and run the program**  

---

## **üìù Full Working Code (Local Execution)**  
```cpp
#include <iostream>
#include <unordered_map>
#include <string>

using namespace std;

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> charIndex;
        int maxLength = 0, left = 0;

        for (int right = 0; right < s.length(); right++) {
            if (charIndex.find(s[right]) != charIndex.end() && charIndex[s[right]] >= left) {
                left = charIndex[s[right]] + 1;
            }
            charIndex[s[right]] = right;
            maxLength = max(maxLength, right - left + 1);
        }
        return maxLength;
    }
};

int main() {
    Solution solution;
    string s;
    
    cout << "Enter a string: ";
    cin >> s;

    int result = solution.lengthOfLongestSubstring(s);
    cout << "Length of longest substring without repeating characters: " << result << endl;

    return 0;
}
```

---

## **üîß Compilation & Execution**  
#### **1Ô∏è‚É£ Compile**  
```bash
g++ -std=c++17 longest_substring.cpp -o longest_substring
```  

#### **2Ô∏è‚É£ Run**  
```bash
./longest_substring
```  

---

## **üéØ Example Run**  
### **Input**  
```
abcabcbb
```
### **Output**  
```
Length of longest substring without repeating characters: 3
```

---

## **üìå Summary**  
‚úÖ **Optimized Sliding Window Approach (O(n) Time Complexity)**  
‚úÖ **Efficient Hash Map Usage for Character Tracking**  
‚úÖ **Handles Edge Cases (Empty String, Single Character, etc.)**  
‚úÖ **Structured for Both LeetCode & Local Execution**  

üöÄ **Now you can seamlessly test this LeetCode C++ solution locally!** üöÄ